<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simple WebRTC Voice Room (Scaledrone)</title>
  <style>
    /* Simple Discord-like layout (minimal) */
    :root{
      --bg:#0f1720; --panel:#111827; --muted:#9ca3af; --accent:#5865f2; --card:#0b1220;
      color: #e5e7eb; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    body { margin:0; min-height:100vh; background:linear-gradient(180deg,#071025 0%, #041524 100%); display:flex; justify-content:center; align-items:center; }
    .app { width:960px; max-width:96%; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; box-shadow:0 10px 30px rgba(2,6,23,0.7); overflow:hidden; display:grid; grid-template-columns: 240px 1fr; gap:0; }
    .sidebar { background:var(--panel); padding:16px; display:flex; flex-direction:column; gap:12px; min-height:420px; }
    .sidebar h2 { margin:0; font-size:14px; letter-spacing:0.6px; color:var(--muted); }
    .rooms { display:flex; flex-direction:column; gap:8px; margin-top:8px; }
    .room { padding:10px 12px; background:var(--card); border-radius:8px; cursor:pointer; font-weight:600; }
    .room.active { outline:2px solid rgba(88,101,242,0.18); box-shadow:0 4px 14px rgba(88,101,242,0.06); }
    .main { padding:20px; display:flex; flex-direction:column; gap:16px; }
    .controls { display:flex; gap:12px; align-items:center; }
    .btn { background:var(--accent); color:white; padding:10px 14px; border-radius:10px; border:none; cursor:pointer; font-weight:700; box-shadow:0 6px 18px rgba(88,101,242,0.18); }
    .btn.secondary { background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); box-shadow:none; font-weight:600; }
    .mute { background:#111; border:1px solid rgba(255,255,255,0.03); padding:10px 12px; border-radius:10px; cursor:pointer; }
    .participants { background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); padding:12px; border-radius:8px; min-height:120px; display:flex; flex-direction:column; gap:8px; }
    .participant { display:flex; gap:10px; align-items:center; padding:6px; border-radius:8px; }
    .dot { width:10px; height:10px; border-radius:50%; background:#10b981; }
    .local { font-weight:700; color:#fff; }
    .small { color:var(--muted); font-size:13px; }
    footer.small { color:var(--muted); font-size:12px; margin-top:10px; }
    .note { color:var(--muted); font-size:13px; }
  </style>
</head>
<body>
  <div class="app" id="app">
    <aside class="sidebar">
      <h2>Voice Rooms</h2>
      <div class="rooms">
        <div class="room active" data-room="lobby"># lobby</div>
        <div class="room" data-room="gaming"># gaming</div>
        <div class="room" data-room="study"># study</div>
      </div>
      <div style="margin-top:auto;">
        <div class="small">Scaledrone signaling</div>
        <div class="note">Replace the CHANNEL_ID in the script with your Scaledrone channel id.</div>
      </div>
    </aside>

    <main class="main">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <h1 style="margin:0; font-size:18px;">Simple Voice Room</h1>
          <div class="small" id="currentRoomLabel">Room: <strong>lobby</strong></div>
        </div>

        <div class="controls">
          <button id="joinBtn" class="btn">Join</button>
          <button id="leaveBtn" class="btn secondary" style="display:none;">Leave</button>
          <button id="muteBtn" class="mute" title="Mute / Unmute">Mute</button>
        </div>
      </div>

      <div style="display:grid; grid-template-columns:1fr 320px; gap:16px;">
        <section>
          <div class="participants" id="participants">
            <div class="small">Participants</div>
            <div id="participantsList"></div>
          </div>
          <div style="margin-top:12px;">
            <div class="small">Local mic level</div>
            <progress id="micLevel" value="0" max="1" style="width:100%;"></progress>
          </div>
        </section>

        <aside>
          <div style="background:var(--panel); padding:12px; border-radius:8px; min-height:120px;">
            <div class="small">Status</div>
            <div id="status" style="margin-top:8px;" class="small">Not connected</div>
            <footer class="small">Tip: Use HTTPS / localhost. Allow microphone access when prompted.</footer>
          </div>
        </aside>
      </div>
    </main>
  </div>

  <script>
  /**************************************************************************
   * Simple WebRTC voice room using Scaledrone for signaling.
   *
   * Replace CHANNEL_ID with your Scaledrone channel ID.
   * Scaledrone docs: https://www.scaledrone.com/
   *
   * How it works (high-level):
   * - Each client connects to Scaledrone and joins a room.
   * - When a new client joins, we exchange SDP offers/answers and ICE candidates
   *   via messages in the Scaledrone room.
   * - Each remote peer gets an <audio> element to play their incoming audio.
   *
   * Note: this is a minimal, educational example. For production:
   * - Add auth (Scaledrone supports presence + auth)
   * - handle reconnections, UI niceties, error cases
   **************************************************************************/

  // ============= CONFIG =============
  const SCALED RONE_CHANNEL_ID = 'YstSSj9UMw4xqYdB'; // <<-- REPLACE this
  // If you want, change the default room name here:
  let roomName = 'lobby';

  // Recommended STUN list
  const iceServers = [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
  ];

  // ============= STATE =============
  let drone; // Scaledrone instance
  let clientId = null;
  let localStream = null;
  let pcMap = new Map(); // peerId -> RTCPeerConnection
  let audioEls = new Map(); // peerId -> audio element
  let participants = new Set(); // peerIds in room
  let joined = false;
  let muted = false;
  // DOM
  const joinBtn = document.getElementById('joinBtn');
  const leaveBtn = document.getElementById('leaveBtn');
  const muteBtn = document.getElementById('muteBtn');
  const participantsList = document.getElementById('participantsList');
  const statusEl = document.getElementById('status');
  const micLevel = document.getElementById('micLevel');
  const currentRoomLabel = document.getElementById('currentRoomLabel');

  // Room selector
  document.querySelectorAll('.room').forEach(item => {
    item.addEventListener('click', () => {
      document.querySelectorAll('.room').forEach(r => r.classList.remove('active'));
      item.classList.add('active');
      roomName = item.dataset.room;
      currentRoomLabel.innerHTML = 'Room: <strong>' + roomName + '</strong>';
    });
  });

  // ============= Helpers =============
  function logStatus(txt) {
    statusEl.textContent = txt;
    console.debug('[status]', txt);
  }

  function uuid() { // simple random string for client id
    return Math.random().toString(36).substr(2, 9);
  }

  function addParticipantEntry(peerId, isLocal=false) {
    const id = 'p_' + peerId;
    if (document.getElementById(id)) return;
    const div = document.createElement('div');
    div.className = 'participant';
    div.id = id;
    div.innerHTML = `<div class="dot"></div>
      <div>
        <div class="${isLocal ? 'local' : ''}">${isLocal ? 'You' : peerId}</div>
        <div class="small">${isLocal ? 'Local microphone' : 'Remote peer'}</div>
      </div>`;
    participantsList.appendChild(div);
  }

  function removeParticipantEntry(peerId) {
    const id = 'p_' + peerId;
    const el = document.getElementById(id);
    if (el) el.remove();
  }

  // ============= Scaledrone signaling =============
  function connectScaledrone() {
    if (!SCALED RONE_CHANNEL_ID || SCALED RONE_CHANNEL_ID.includes('YOUR_SCALED')) {
      alert('Please replace the SCALED RONE CHANNEL ID in the script with your Scaledrone channel ID.');
      throw new Error('Missing Scaledrone channel ID');
    }
    // Scaledrone library load (we inject script dynamically)
    return new Promise((resolve, reject) => {
      if (window.Scaledrone) return resolve();
      const s = document.createElement('script');
      s.src = 'https://cdn.scaledrone.com/scaledrone.min.js';
      s.onload = () => resolve();
      s.onerror = reject;
      document.head.appendChild(s);
    }).then(() => {
      clientId = uuid();
      drone = new Scaledrone(SCALED RONE_CHANNEL_ID, { data: { clientId } });
      drone.on('open', (error) => {
        if (error) {
          logStatus('Scaledrone connection error: ' + error);
          console.error(error);
          return;
        }
        logStatus('Connected to Scaledrone as ' + clientId);
      });
      // Subscribe to a room for signaling
      const room = drone.subscribe('observable-' + roomName);
      room.on('open', () => {
        logStatus('Joined signaling room: ' + roomName);
      });
      room.on('data', (message, member) => {
        // ignore our own messages (we tag them with our clientId)
        if (!message || message.clientId === clientId) return;
        handleSignalingMessage(message);
      });
      // presence: track who is in the room
      room.on('members', members => {
        // members is an array of member objects (each has id and clientData)
        // We use clientData to get clientId if available.
        participants.clear();
        members.forEach(m => {
          const id = (m.clientData && m.clientData.clientId) ? m.clientData.clientId : (m.id || 'member-' + Math.random());
          if (id !== clientId) participants.add(id);
        });
        refreshParticipantsUI();
      });
      room.on('member_join', m => {
        const id = (m.clientData && m.clientData.clientId) ? m.clientData.clientId : (m.id || 'member-' + Math.random());
        if (id === clientId) return;
        participants.add(id);
        refreshParticipantsUI();
        // When someone new joins, we should create a peer connection and offer to them
        createOfferForPeer(id);
      });
      room.on('member_leave', m => {
        const id = (m.clientData && m.clientData.clientId) ? m.clientData.clientId : (m.id || 'member-' + Math.random());
        participants.delete(id);
        cleanupPeer(id);
      });
    });
  }

  function sendMessage(msg) {
    if (!drone) return;
    drone.publish({
      room: 'observable-' + roomName,
      message: Object.assign({}, msg, { clientId })
    });
  }

  // ============= WebRTC logic =============
  function createPeerConnection(peerId) {
    if (pcMap.has(peerId)) return pcMap.get(peerId);

    const pc = new RTCPeerConnection({ iceServers });
    pcMap.set(peerId, pc);

    // Add local tracks
    if (localStream) {
      for (const track of localStream.getTracks()) {
        pc.addTrack(track, localStream);
      }
    }

    // Remote stream handling
    const remoteStream = new MediaStream();
    const audio = document.createElement('audio');
    audio.autoplay = true;
    audio.playsInline = true;
    audio.srcObject = remoteStream;
    audio.dataset.peerId = peerId;
    audio.style.display = 'none'; // hidden, but will play audio
    document.body.appendChild(audio);
    audioEls.set(peerId, audio);

    pc.ontrack = (ev) => {
      for (const t of ev.streams) {
        t.getAudioTracks().forEach(() => {});
        // attach
        audio.srcObject = ev.streams[0];
      }
    };

    pc.onicecandidate = (event) => {
      if (event.candidate) {
        sendMessage({ type: 'candidate', to: peerId, candidate: event.candidate });
      }
    };

    pc.onconnectionstatechange = () => {
